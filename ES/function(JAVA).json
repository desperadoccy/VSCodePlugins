{"index":{}}
{"id": "80", "language": "JAVA", "method_body": "import java util Queue nimport java util Scanner nimport java util concurrent LinkedBlockingDeque n SPFA Floyd kruskal Dijkstra DFS npublic class Main n static class Edge n int v w next n Edge int v int w int next n this v v n this w w n this next next n n n static final int N n static final int M n static final int INF x f f f f n static int n m s t u v w cnt n static int head new int N n static Edge edges new Edge M n static int dis new int N n static boolean vis new boolean N n static int inq new int N n static void init n cnt n for int i i n i n head i n n n static void addEdge int u int v int w n edges cnt new Edge v w head u n head u cnt n edges cnt new Edge u w head v n head v cnt n n static boolean spfa n for int i i n i n vis i false n inq i n dis i INF n n dis s n vis s true n Queue Integer q new LinkedBlockingDeque n q add s n inq s n while q isEmpty n int u q poll n vis u false n for int i head u i i edges i next n int v edges i v n int w edges i w n if dis v dis u w n dis v dis u w n if vis v n vis v true n q add v n if inq v n n return false n n n n n n return true n n public static void main String args n Scanner cin new Scanner System in n n cin nextInt n m cin nextInt n s cin nextInt n t cin nextInt n init n while m n u cin nextInt n v cin nextInt n w cin nextInt n addEdge u v w n n spfa n System out println dis t n n n n", "content": "import java.util.Queue;\\nimport java.util.Scanner;\\nimport java.util.concurrent.LinkedBlockingDeque;\\n/*  SPFA Floyd  kruskal Dijkstra DFS*/ \\npublic class Main {\\n    static class Edge{\\n        int v,w,next;\\n        Edge(int v,int w,int next){\\n            this.v=v;\\n            this.w=w;\\n            this.next=next;\\n        }\\n    }\\n    static final int N= 100500;\\n    static final int M=1000050;\\n    static final int INF=0x3f3f3f3f;\\n    static int n,m,s,t,u,v,w,cnt;\\n    static int[] head=new int[N];\\n    static Edge[] edges=new Edge[M];\\n    static int[] dis=new int[N];\\n    static boolean[] vis=new boolean[N];\\n    static int[] inq=new int[N];\\n    static void init(){\\n        cnt=0;\\n        for(int i=1;i<=n;i++){\\n            head[i]=-1;\\n        }\\n    }\\n    static void addEdge(int u,int v,int w){\\n        edges[cnt]=new Edge(v,w,head[u]);\\n        head[u]=cnt++;\\n        edges[cnt]=new Edge(u,w,head[v]);\\n        head[v]=cnt++;\\n    }\\n    static boolean spfa(){\\n        for(int i=1;i<=n;i++){\\n            vis[i]=false;\\n            inq[i]=0;\\n            dis[i]=INF;\\n        }\\n        dis[s]=0;\\n        vis[s]=true;\\n        Queue<Integer> q=new LinkedBlockingDeque<>();\\n        q.add(s);\\n        inq[s]=1;\\n        while(!q.isEmpty()){\\n            int u=q.poll();\\n            vis[u]=false;\\n            for(int i=head[u];i!=-1;i=edges[i].next){\\n                int v=edges[i].v;\\n                int w=edges[i].w;\\n                if(dis[v]>dis[u]+w){\\n                    dis[v]=dis[u]+w;\\n                    if(!vis[v]){\\n                        vis[v]=true;\\n                        q.add(v);\\n                        if(++inq[v]>n){\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public static void main(String[] args) {\\n        Scanner cin=new Scanner(System.in);\\n        n=cin.nextInt();\\n        m=cin.nextInt();\\n        s=cin.nextInt();\\n        t=cin.nextInt();\\n        init();\\n        while(m-->0){\\n            u=cin.nextInt();\\n            v=cin.nextInt();\\n            w=cin.nextInt();\\n            addEdge(u,v,w);\\n        }\\n        spfa();\\n        System.out.println(dis[t]);\\n    }\\n}\\n\\n"}
{"index":{}}
{"id": "81", "language": "JAVA", "method_body": "import java util Scanner n SPFA Floyd kruskal Dijkstra DFS npublic class Main n static int m n u v w n static final int N n static final int INF x f f f f n static long g new long N N n static void floyd n for int k k n k n for int i i n i n for int j j n j n if g i j g i k g k j n g i j g i k g k j n n n n n npublic static void main String args n Scanner cin new Scanner System in n n cin nextInt n m cin nextInt n for int i i n i n for int j j n j n g i j i j INF n n n while m n u cin nextInt n v cin nextInt n w cin nextInt n if w g u v n g u v g v u w n n n floyd n for int i i n i n for int j j n j n if j n System out print n n System out print g i j n n System out println n n n n n", "content": "import java.util.Scanner;\\n/*  SPFA Floyd  kruskal Dijkstra DFS*/ \\npublic class Main{\\n    static int m,n,u,v,w;\\n    static final int N=150;\\n    static final int INF=0x3f3f3f3f;\\n    static long[][] g=new long[N][N];\\n    static void floyd(){\\n        for(int k=1;k<=n;k++){\\n            for(int i=1;i<=n;i++){\\n                for(int j=1;j<=n;j++){\\n                    if(g[i][j]>g[i][k]+g[k][j]){\\n                        g[i][j]=g[i][k]+g[k][j];\\n                    }\\n                }\\n            }\\n        }\\n    }\\npublic static void main(String[] args) {\\n    Scanner cin=new Scanner(System.in);\\n    n=cin.nextInt();\\n    m=cin.nextInt();\\n    for(int i=1;i<=n;i++){\\n        for(int j=1;j<=n;j++){\\n            g[i][j]=i==j?0:INF;\\n        }\\n    }\\n    while(m-->0){\\n        u=cin.nextInt();\\n        v=cin.nextInt();\\n        w=cin.nextInt();\\n        if(w<g[u][v]){\\n            g[u][v]=g[v][u]=w;\\n        }\\n    }\\n    floyd();\\n    for(int i=1;i<=n;i++){\\n        for(int j=1;j<=n;j++){\\n            if(j!=1){\\n                System.out.print(\" \");\\n            }\\n            System.out.print(g[i][j]);\\n        }\\n        System.out.println();\\n    }\\n}\\n}\\n\\n"}
{"index":{}}
{"id": "82", "language": "JAVA", "method_body": "import java util ArrayList nimport java util Arrays nimport java util Collections nimport java util Scanner n SPFA Floyd kruskal Dijkstra DFS npublic class Main n static class Edge implements Comparable Edge n int u v w n Edge int u int v int w n this u u n this v v n this w w n n n n Override n public int compareTo Edge o n return w o w n n n static final int N int e n static final int M int e n static int T n m u v w cnt n static int p new int N n static Edge edges new Edge M n n static void addEdge int u int v int w n edges cnt new Edge u v w n n static int find int x n return p x x x p x find p x n n static int Kruskal n int ans n int c n for int i i n i n p i i n n Arrays sort edges cnt n for int i i cnt i n int u edges i u n int v edges i v n int w edges i w n int fa find u n int fb find v n if fa fb n n ans w n n ans w n p fa fb n c n n if c n n break n n n if c n n n return n n return ans n n public static void main String args n Scanner cin new Scanner System in n T cin nextInt n while T n cnt n n cin nextInt n m cin nextInt n while m n u cin nextInt n v cin nextInt n w cin nextInt n addEdge u v w n n int ans Kruskal n System out println ans n n n n n", "content": "import java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.Scanner;\\n/*  SPFA Floyd  kruskal Dijkstra DFS*/ \\npublic class Main{\\n    static class Edge implements Comparable<Edge>{\\n        int u,v,w;\\n        Edge(int u,int v,int w){\\n            this.u=u;\\n            this.v=v;\\n            this.w=w;\\n        }\\n\\n\\n        @Override\\n        public int compareTo(Edge o) {\\n            return w-o.w;\\n        }\\n    }\\n    static final int N=(int)1e6+50;\\n    static final int M=(int)2e6+50;\\n    static int T,n,m,u,v,w,cnt;\\n    static int[] p=new int[N];\\n    static Edge[] edges=new Edge[M];\\n\\n    static void addEdge(int u,int v,int w){\\n        edges[cnt++]=new Edge(u,v,w);\\n    }\\n    static int find(int x){\\n        return p[x]==x?x:(p[x]=find(p[x]));\\n    }\\n    static int Kruskal(){\\n        int ans=0;\\n        int c=0;\\n        for(int i=0;i<=n;i++){\\n            p[i]=i;\\n        }\\n        Arrays.sort(edges,0,cnt);\\n        for(int i=0;i<cnt;i++){\\n            int u=edges[i].u;\\n            int v=edges[i].v;\\n            int w=edges[i].w;\\n            int fa=find(u);\\n            int fb=find(v);\\n            if(fa!=fb){\\n                //求权值和\\n                //ans+=w;\\n                //求最长边\\n                ans=w;\\n                p[fa]=fb;\\n                c++;\\n            }\\n            if(c==n-1){\\n                break;\\n            }\\n        }\\n        if(c<n-1){\\n            //未连通\\n            return -1;\\n        }\\n        return ans;\\n    }\\n    public static void main(String[] args) {\\n        Scanner cin=new Scanner(System.in);\\n        T=cin.nextInt();\\n        while(T-->0){\\n            cnt=0;\\n            n=cin.nextInt();\\n            m=cin.nextInt();\\n            while(m-->0){\\n                u=cin.nextInt();\\n                v=cin.nextInt();\\n                w=cin.nextInt();\\n                addEdge(u,v,w);\\n            }\\n            int ans=Kruskal();\\n            System.out.println(ans);\\n        }\\n    }\\n}\\n\\n"}
{"index":{}}
{"id": "83", "language": "JAVA", "method_body": "import java util Arrays nimport java util Scanner n SPFA Floyd kruskal Dijkstra DFS npublic class Main n public static final int N n public static final int INF x f f f f n public static int cost new int N N n public static int dis new int N n public static boolean vis new boolean N n public static int n m s t n public static int u v w n public static void main String args n Scanner scanner new Scanner System in n while scanner hasNextInt n n scanner nextInt n m scanner nextInt n if n m n break n n for int i i N i n for int j j N j n cost i j INF n n n for int i i m i n u scanner nextInt n v scanner nextInt n w scanner nextInt n cost u v cost v u w n n s n t n n Dijkstra n System out println dis t n n n n public static void Dijkstra n for int i i n i n dis i INF n vis i false n n dis s n for int i i n i n int k n int Min INF n for int j j n j n if vis j dis j Min n Min dis j n k j n n n if k n break n n vis k true n for int j j n j n if vis j dis k cost k j dis j n dis j dis k cost k j n n n n n n n", "content": "import java.util.Arrays;\\nimport java.util.Scanner;\\n/*  SPFA Floyd  kruskal Dijkstra DFS*/ \\npublic class Main {\\n    public static final int N=1050;\\n    public static final int INF=0x3f3f3f3f;\\n    public static int[][] cost=new int[N][N];\\n    public static int[] dis=new int[N];\\n    public static boolean[] vis=new boolean[N];\\n    public static int n,m,s,t;\\n    public static int u,v,w;\\n    public static void main(String[] args) {\\n        Scanner scanner=new Scanner(System.in);\\n        while(scanner.hasNextInt()){\\n            n=scanner.nextInt();\\n            m=scanner.nextInt();\\n            if(n==0 && m==0){\\n                break;\\n            }\\n            for(int i=0;i<N;i++){\\n                for(int j=0;j<N;j++){\\n                    cost[i][j]=INF;\\n                }\\n            }\\n            for(int i=0;i<m;i++){\\n                u=scanner.nextInt();\\n                v=scanner.nextInt();\\n                w=scanner.nextInt();\\n                cost[u][v]=cost[v][u]=w;\\n            }\\n            s=1;\\n            t=n;\\n            Dijkstra();\\n            System.out.println(dis[t]);\\n        }\\n    }\\n\\n    public static void Dijkstra(){\\n        for(int i=1;i<=n;i++){\\n            dis[i]=INF;\\n            vis[i]=false;\\n        }\\n        dis[s]=0;\\n        for(int i=1;i<n;i++){\\n            int k=-1;\\n            int Min=INF;\\n            for(int j=1;j<=n;j++){\\n                if(!vis[j] && dis[j]<Min){\\n                    Min=dis[j];\\n                    k=j;\\n                }\\n            }\\n            if(k==-1){\\n                break;\\n            }\\n            vis[k]=true;\\n            for(int j=1;j<=n;j++){\\n                if(!vis[j] && dis[k]+cost[k][j]<dis[j]){\\n                    dis[j]=dis[k]+cost[k][j];\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n"}
{"index":{}}
{"id": "84", "language": "JAVA", "method_body": " SPFA Floyd kruskal Dijkstra DFS npublic static void DFS int v n visited v true n for int i i a length i n if check visited i false n DFS i n n n n n public static void DFS TreeNode head n if head null return n check check n if head left null n DFS head left n if head right null n DFS head right n n n n", "content": "/*  SPFA Floyd  kruskal Dijkstra DFS*/ \\npublic static void DFS(int v){//图的深搜\\n        visited[v]=true;\\n        for (int i = 0; i < a[0].length; i++) {\\n            if (check()&&visited[i]==false){\\n                DFS(i);//回溯\\n            }\\n        }\\n    }\\n\\n    public static void DFS(TreeNode head){//树的深搜使用回溯\\n        if (head==null)return;\\n        check();//满足条件的check();\\n        if (head.left!=null){\\n            DFS(head.left);\\n        }if (head.right!=null){\\n            DFS(head.right);\\n        }\\n    }\\n\\n"}
{"index":{}}
{"id": "85", "language": "JAVA", "method_body": " SPFA Floyd kruskal Dijkstra DFS npublic static void BFS int v n Queue Integer queue new LinkedList n Boolean visited new Boolean a length a length n visited v true n queue add v n int prev new int a length a length n int l n prev l n while queue size n int v queue poll n for int i i a length i v n if visited i false check check n queue add i n prev l i n n visited i true n n n n npublic static void BFS TreeNode head n if head null return n Queue TreeNode queue new LinkedList n queue offer head n while queue isEmpty n TreeNode m queue poll n System out print m val n dosomething n if m left null n queue offer m left n if m right null n queue offer m right n n queue poll n n n n", "content": "/*  SPFA Floyd  kruskal Dijkstra DFS*/ \\npublic static void BFS(int v){//图的宽搜\\n    Queue<Integer> queue=new LinkedList<>();\\n    Boolean[] visited=new Boolean[a.length*a[0].length];//已被访问节点\\n    visited[v]=true;\\n    queue.add(v);\\n    int []prev=new int[a.length*a[0].length];\\n    int l=0;\\n    prev[l]=0;\\n    while (queue.size()!=0){\\n        int v2=queue.poll();\\n        for (int i = 0; i <a[0].length ; i++) {//从v2点开始往下搜\\n            if (visited[i]==false&&check()){//结点满足条件的check();\\n                queue.add(i);\\n                prev[++l]=i;\\n            }\\n            visited[i]=true;\\n        }\\n    }\\n}\\n\\npublic static void BFS(TreeNode head){//树的宽搜\\n    if (head==null)return;\\n    Queue<TreeNode> queue=new LinkedList<>();\\n    queue.offer(head);\\n    while (!queue.isEmpty()){\\n        TreeNode m=queue.poll();\\n        //System.out.print(m.val+\" \");\\n        //dosomething();\\n        if (m.left!=null){\\n            queue.offer(m.left);\\n        }if (m.right!=null){\\n            queue.offer(m.right);\\n        }\\n        queue.poll();\\n    }\\n}\\n\\n"}
