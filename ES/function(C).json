{"index":{}}
{"id": "1", "language": "C&C++", "method_body": " include iostream n include cstring nusing namespace std nint main n n tstring str str n tint a b len t t n tint i n tmemset a sizeof a n tmemset b sizeof b n tcin str str t t n ta str length t n tfor i i a i t a n t t ta i str a i n tb str length t t n tfor i i b i t t B n t t tb i str b i n tlen a b ta b t t n tfor i i len i t t n t n t t ta i b i n t t ta i a i n t t ta i t t t n t n tlen t t t n twhile a len len len n tfor i len i i n t t tcout a i n treturn t n n", "content": "#include<iostream>\\n#include<cstring>\\nusing namespace std;\\nint main()\\n{\\n\\tstring str1,str2;\\n\\tint a[250],b[250],len;\\t\\t//数组的大小决定了计算的高精度最大位数\\n\\tint i;\\n\\tmemset(a,0,sizeof(a));\\n\\tmemset(b,0,sizeof(b));\\n\\tcin>>str1>>str2;\\t\\t//输入两个字符串\\n\\ta[0]=str1.length();\\t//取得第一个字符串的长度\\n\\tfor(i=1;i<=a[0];i++)\\t//把第一个字符串转换为整数，存放在数组a中\\n\\t\\t\\ta[i]=str1[a[0]-i]-'0';\\n\\tb[0]=str2.length();\\t\\t//取得第二个字符串长度\\n\\tfor(i=1;i<=b[0];i++)\\t\\t//把第二个字符串中的每一位转换为整数，存放在数组B中\\n\\t\\t\\tb[i]=str2[b[0]-i]-'0';\\n\\tlen=(a[0]>b[0]\\ta[0]:b[0]); \\t\\t//取两个字符串最大的长度\\n\\tfor(i=1;i<=len;i++)\\t\\t//做按位加法，同时处理进位\\n\\t{\\n\\t\\t\\ta[i]+=b[i];\\n\\t\\t\\ta[i+1]+=a[i]/10;\\n\\t\\t\\ta[i]%=10;\\t\\t\\t\\n\\t}\\n\\tlen++;\\t\\t\\t//下面是去掉最高位的0，然后输出。\\n\\twhile((a[len]==0)&&(len>1)) len--;\\n\\tfor(i=len;i>=1;i--)\\n\\t\\t\\tcout<<a[i];\\n\\treturn 0;\\t\\n}\\n"}
{"index":{}}
{"id": "2", "language": "C&C++", "method_body": "void bfs void G n n n Q visited n tfor v v n v n t tvisited v n tfor v v n v n t tif visited v n t t t t t t t t t v n t t tint h r t t t q n t t tvisited v v n t t tcout v v n t t tq r v t t v n t t twhile h r n t t t n t t t tint tmp q h t tmp n t t t tfor int j j n j n t t t t tif visited j a tmp j n t t t t t j tmp n t t t t t tvisited j t j n t t t t t tcout j j n t t t t t tr n t t t t t tq r j j n t t t t t t end if n t t t th n t t t end while n t t n n", "content": "void bfs(void) //按广度优先非递归遍历图G，n个顶点，编号为1..n。注：图不一定是连通的\\n{//使用辅助队列Q和访问标记数组visited。\\n\\tfor(v=1;v<=n;v++)\\n\\t\\tvisited[v]=0;//标记数组初始化\\n\\tfor(v=1; v<=n; v++)\\n\\t\\tif(visited[v]==0 )\\n\\t\\t{\\t\\t\\t\\t\\t\\t\\t//v尚未访问\\n\\t\\t\\tint h=1,r=1;\\t\\t\\t//置空的辅助队列q\\n\\t\\t\\tvisited[v]=1;//顶点v,作访问标记\\n\\t\\t\\tcout<<v<<' '; //访问顶点v\\n\\t\\t\\tq[r]=v;\\t\\t//v入队列\\n\\t\\t\\twhile(h<=r) //当队列非空时循环\\n\\t\\t\\t{\\n\\t\\t\\t\\tint tmp=q[h];\\t//队头元素出队，并赋值给tmp\\n\\t\\t\\t\\tfor(int j=1;j<=n;j++)\\n\\t\\t\\t\\t\\tif((visited[j]==0)&&(a[tmp][j]==1))\\n\\t\\t\\t\\t\\t{//j为tmp的尚未访问的邻接顶点\\n\\t\\t\\t\\t\\t\\tvisited[j]=1;//\\t对j作访问标记\\n\\t\\t\\t\\t\\t\\tcout<<j<<' ';// 访问j\\n\\t\\t\\t\\t\\t\\tr++; //队尾指针加1\\n\\t\\t\\t\\t\\t\\tq[r]=j; //j入队\\n\\t\\t\\t\\t\\t}\\t//end-if\\n\\t\\t\\t\\th++;\\n\\t\\t\\t}//end -while\\n\\t\\t}\\n}\\n"}
{"index":{}}
{"id": "3", "language": "C&C++", "method_body": "int Binary Search int x int y int m x y m n n t tint head tail mid n t thead x tail y mid x y n t tif a mid m return mid m mid n t tif head tail return x y n t tif m a mid t m n t t t treturn Binary Search mid tail n t telse m n t t t treturn Binary Search head mid n n", "content": "int Binary_Search(int x,int y,int m) //在[x,y]区间查找关键字等于m的元素下标\\n{\\n\\t\\tint head,tail,mid;\\n\\t\\thead=x;tail=y;mid=((x+y)/2);//取中间元素下标\\n\\t\\tif(a[mid]==m) return mid;//如果中间元素值为m返回中间元素下标mid\\n\\t\\tif(head>tail) return 0;//如果x>y，查找失败，返回0\\n\\t\\tif(m>a[mid])\\t //如果m比中间元素大，在后半区间查找，返回后半区间查找结果\\n\\t\\t\\t\\treturn Binary_Search(mid+1,tail);\\n\\t\\telse //如果m比中间元素小，在前半区间查找，返回后前区间查找结果\\n\\t\\t\\t\\treturn Binary_Search(head,mid-1);\\n}\\n"}
{"index":{}}
{"id": "4", "language": "C&C++", "method_body": "void Bubble Sort a a n n n tfor int i i n i n n n t tfor int j j n i j n t t tif a j a j n t t t n t t t tint temp a j n t t t ta j a j n t t t ta j temp n t t t n n", "content": "void Bubble_Sort() //待排序的数据存放在a[1]..a[n]数组中\\n{\\n\\tfor(int i=1;i<n;i++) //控制循环（冒泡）的次数，n个数，需要n-1次冒泡\\n\\t\\tfor(int j=1;j<=n-i;j++) //相邻的两两比较\\n\\t\\t\\tif(a[j]<a[j+1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tint temp=a[j];\\n\\t\\t\\t\\ta[j]=a[j+1];\\n\\t\\t\\t\\ta[j+1]=temp;\\n\\t\\t\\t}\\n}\\n"}
{"index":{}}
{"id": "5", "language": "C&C++", "method_body": "void bucketsort void a a cmax n n tmemset bucket sizeof bucket n tfor int i i n i n n t n t tint a n t tcin a n t tbucket a n t n tfor int i i cmax i n t n t tif bucket i i bucket i i n t twhile bucket i n t t n t t tbucket i n t t tcout i n t t n t n n", "content": "void bucketsort(void)//a的取值范围已知。如a<=cmax。\\n{\\n\\tmemset(bucket,0,sizeof(bucket));//桶初始化\\n\\tfor(int i=1;i<=n;i++)//读入n个数\\n\\t{\\n\\t\\tint a\\n\\t\\tcin>>a;\\n\\t\\tbucket[a]++;\\n\\t}//相应的桶号计数器加1\\n\\tfor(int i=1;i<=cmax;i++)\\n\\t{\\n\\t\\tif(bucket[i]>0) //当桶中装的树大于0，说明i出现过bucket[i]次，否则没出现过i\\n\\t\\twhile (bucket[i]!=0)\\n\\t\\t{\\n\\t\\t\\tbucket[i]--;\\n\\t\\t\\tcout<<i<<' ';\\n\\t\\t}\\n\\t}\\n}\\n"}
{"index":{}}
{"id": "6", "language": "C&C++", "method_body": "void dfs int x t n t t t t n t t t t tcout x x n t t t t tvisited x n t t t t tfor int k k n k x k n t t t t t t tif a x k visited k n t t t t t t t tdfs k n t t t n", "content": "void dfs(int x)\\t//以图的深度优先遍历为例。\\n\\t\\t\\t{\\t\\n\\t\\t\\t\\t\\tcout<<x<<' '; //访问x顶点\\n\\t\\t\\t\\t\\tvisited[x]=1; //作已访问的标记\\n\\t\\t\\t\\t\\tfor(int k=1;k<=n;k++) //对与顶点x相邻而又没访问过的结点k进行深度优先搜索。\\n\\t\\t\\t\\t\\t\\t\\tif((a[x][k]==1)&&(visited[k]==0))\\n\\t\\t\\t\\t\\t\\t\\t\\tdfs(k);\\n\\t\\t\\t}\\n"}
{"index":{}}
{"id": "7", "language": "C&C++", "method_body": "void dijkstra int x t x n n t tmemset vis sizeof vis vis i i n t tvis x pre x n t tfor int i i n i t t n t t tif i x n t t t n t t t tdis i g x i n t t t tpre i x n t t t n t tfor int i i n i t t n x n n t t n t t tint m big big n t t tint k x n t t tfor int j j n j t t n t t t tif vis j m dis j n t t t t n t t t t tm dis j n t t t t tk j n t t t t n t t tvis k t t k X n t t tfor int j j n j t t X n t t t tif vis j dis k g k j dis j n t t t t t t t n t t t t tdis j dis k g k j t n t t t t tpre j k t n t t t t n t t n n", "content": "void dijkstra(int x)\\t//求结点x到各个结点的最短路径\\n{\\n\\t\\tmemset(vis,0,sizeof(vis)); //初始化，vis[i]＝0表示源点到结点i未求，否则已求\\n\\t\\tvis[x]=1;pre[x]=0; //初始化源点。\\n\\t\\tfor(int i=1;i<=n;i++)\\t\\t//对其它各点初始化。\\n\\t\\t\\tif(i!=x)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdis[i]=g[x][i];\\n\\t\\t\\t\\tpre[i]=x;\\n\\t\\t\\t}\\n\\t\\tfor(int i=1;i<=n-1;i++)\\t\\t//对于n个结点的图，要求x到其它n-1个结点的最短距离\\n\\t\\t{\\n\\t\\t\\tint m=big; //虚拟一个最大的数big=99999999;\\n\\t\\t\\tint k=x;\\n\\t\\t\\tfor(int j=1;j<=n;j++)\\t\\t//在未求出的结点中找一个源点到其距离最小的点\\n\\t\\t\\t\\tif(vis[j]==0&&m>dis[j])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm=dis[j];\\n\\t\\t\\t\\t\\tk=j;\\n\\t\\t\\t\\t}\\n\\t\\t\\tvis[k]=1;\\t\\t//思考：如果k=X说明什么？说明后面的点，无解。\\n\\t\\t\\tfor(int j=1;j<=n;j++)\\t\\t//用当前找的结点更新未求结点到X的最短路径\\n\\t\\t\\t\\tif((vis[j]==0)&&(dis[k]+g[k][j]<dis[j]))\\n\\t\\t\\t\\t{\\t\\t\\t\\n\\t\\t\\t\\t\\tdis[j]=dis[k]+g[k][j];\\t//更新\\n\\t\\t\\t\\t\\tpre[j]=k;\\t//保存前趋结点，以便后面求路径\\n\\t\\t\\t\\t}\\n\\t\\t}\\n}\\n"}
{"index":{}}
{"id": "8", "language": "C&C++", "method_body": "void floyed void a i j i j I J n n tfor int k k n k K f i j K DP n t tfor int i i n i i j i J DP n t t tfor int j j n j n t t tif a i j a i k a k j a i j a i k a k j n n", "content": "void floyed(void)// a[i][j]表示结点i到结点j的最短路径长度，初始时值为<I,J>的权值。\\n{\\n\\tfor(int k=1;k<=n;k++) //枚举中间加入的结点不超过K时f[i][j]最短路径长度，K相当DP中的阶段\\n\\t\\tfor(int i=1;i<=n;i++) //i，j是结点i到结点J，相当于DP中的状态\\n\\t\\t\\tfor(int j=1;j<=n;j++)\\n\\t    \\t\\tif (a[i][j]>a[i][k]+a[k][j]) a[i][j]=a[i][k]+a[k][j];//这是决策，加和不加中间点，取最小的值\\n}\\n"}
{"index":{}}
{"id": "9", "language": "C&C++", "method_body": "int getfather int x X n n twhile x father x n t tx father x n treturn x n n t nint getfather int x X n n tif x father x return x n telse return getfather father x t n n t nint getfather int x X n n tint p x n twhile p father p P n t tp father p n twhile x father x X X n t t n t t tint temp father x X n t t tfather x p X P n t t tx temp n t t n treturn p n n t nint getfather int x X n n tif x father x return x n telse n t n t tint temp getfather father x n t tfather x temp n t treturn temp n t n n t nvoid merge int x int y x y n n t tint x x n t tx getfather x X n t tx getfather y Y n t tif x x father x x X Y n n", "content": "int getfather(int x)//非递归求X结点的根结点的编号\\n{\\n\\twhile(x!=father[x])\\n\\t\\tx=father[x];\\n\\treturn x;\\n}\\n\\t\\nint getfather(int x)//递归求X结点的根结点的编号\\n{\\n\\tif(x==father[x]) return x;\\n\\telse return getfather(father[x]);\\t\\n}\\n\\t\\nint getfather(int x)//非递归求X结点的根结点编号同时进行路径压缩\\n{\\n\\tint p=x;\\n\\twhile(p!=father[p])//循环结束后，P即为根结点\\n\\t\\tp=father[p];\\n\\twhile(x!=father[x])//从X结点沿X的父结点进行路径压缩\\n\\t\\t{\\n\\t\\t\\tint temp=father[x];//暂存X没有修改前的父结点\\n\\t\\t\\tfather[x]=p;//把X的父结点指向P\\n\\t\\t\\tx=temp;\\n\\t\\t}\\n\\treturn p;\\n}\\n\\t\\nint getfather(int x)//递归求X结点的根结点编号同时进行路径压缩\\n{\\n\\tif(x==father[x]) return x;\\n\\telse\\n\\t{\\n\\t\\tint temp=getfather(father[x]);\\n\\t\\tfather[x]=temp;\\n\\t\\treturn temp;\\n\\t}\\n}\\n\\t\\nvoid merge(int x,int y)//合并x,y两个结点\\n{\\n\\t\\tint x1,x2;\\n\\t\\tx1=getfather(x);//取得X的父结点\\n\\t\\tx2=getfather(y);//取得Y的父结点\\n\\t\\tif(x1!=x2) father[x1]=x2; //两个父结点不同的话就合并，注意：合并的是X，Y两个结点的根。\\n}\\n"}
{"index":{}}
{"id": "10", "language": "C&C++", "method_body": "void haff void n n t tfor int i n i n i n n t t t t n t t t t tint l fmin i l n t t t t ta i lchild l l i n t t t t ta l father i l i n t t t t tint r fmin i r n t t t t ta i rchild r l i n t t t t ta r father i r i n t t t t ta i da a l da a r da l j i n t t t t n nint fmin int k K n n tint mins n tfor int s s k s n t t tif a mins da a s da a s father a s father n t t tmins s n treturn mins n nvoid inorder int x n n tif a x father a x code n tif a a x father lchild x ta x code a a x father code n tif a a x father rchild x ta x code a a x father code n tif a x lchild inorder a x lchild n tif a x lchild a x rchild n t tcout a x da a x code endl n tif a x rchild inorder a x rchild n n", "content": "void haff(void) //构建哈夫曼树\\n{\\n\\t\\tfor(int i=n+1;i<=2*n-1;i++) //依次生成n-1个结点\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint l=fmin(i-1); //查找权值最小的结点的编号l\\n\\t\\t\\t\\t\\ta[i].lchild=l; //把l作为结点i的左孩子\\n\\t\\t\\t\\t\\ta[l].father=i; //把l的父结点修改为i\\n\\t\\t\\t\\t\\tint r=fmin(i-1); //查找次小权值的编号r\\n\\t\\t\\t\\t\\ta[i].rchild=r; //把l作为结点i的右孩子\\n\\t\\t\\t\\t\\ta[r].father=i; //把r的父结点修改为i\\n\\t\\t\\t\\t\\ta[i].da=a[l].da+a[r].da; //合并l,j结点，生成新结点i\\n\\t\\t\\t\\t}\\n}\\nint fmin(int k)//在1到K中寻找最小的权值的编号\\n{\\n\\tint mins=0;\\n\\tfor(int s=1;s<=k;s++)\\n\\t\\t\\tif((a[mins].da>a[s].da)&&(a[s].father==0)) //a[s].father=0,说明这个结点还不是别个结点\\n\\t\\t\\tmins=s;//的孩子，不等于0说明这个结点已经用过。\\n\\treturn mins;\\n}\\nvoid inorder(int x)//递归生成哈夫曼编码\\n{\\n\\tif(a[x].father==0) {a[x].code=\"\";}//根结点\\n\\tif(a[a[x].father].lchild==x)\\ta[x].code=a[a[x].father].code+'0';\\n\\tif(a[a[x].father].rchild==x)\\ta[x].code=a[a[x].father].code+'1';\\n\\tif(a[x].lchild!=0) inorder(a[x].lchild);//递归生成左子树\\n\\tif((a[x].lchild==0)&&(a[x].rchild==0))//输出叶子结点\\n\\t\\tcout<<a[x].da<<':'<<a[x].code<<endl;\\n\\tif(a[x].rchild!=0) inorder(a[x].rchild);//递归生成右子树\\n}\\n"}
{"index":{}}
{"id": "11", "language": "C&C++", "method_body": "void qsort int x int y n n tint h x r y m elist h r w n twhile h r n t n twhile elist h w m h n t twhile elist r w m r n tif h r n t n t tedge tmp elist h elist h elist r elist r tmp h r n t n tif x r qsort x r n tif h y qsort h y n n t nint getfather int x n n tif x father x return x n telse n t n t tint f getfather father x n t tfather x f n t treturn f n t n n t nvoid merge int x int y x y x y n n tfather x y n n t nvoid kruscal void n n tint sum ans n tqsort t t n tfor int i i t i n t n t tint x getfather elist i from i n t tint x getfather elist i to i n t tif x x n t t n t t tsum n t t tmerge x x n t t tans elist i w n t t i n tif sum n n t tbreak n n t n tif sum n n t tcout Impossible endl t n n telse t n t tcout ans endl n n", "content": "void qsort(int x,int y)//对边集数组进行快速排序\\n{\\n\\tint h=x,r=y,m=elist[(h+r)>>1].w;\\n\\twhile(h<r)\\n\\t{\\n\\twhile(elist[h].w<m) h++;\\n\\t\\twhile(elist[r].w>m) r--;\\n\\tif(h<=r)\\n\\t{\\n\\t\\tedge tmp=elist[h];elist[h]=elist[r];elist[r]=tmp;h++;r--;}\\n\\t}\\n\\tif(x<r) qsort(x,r);\\n\\tif(h<y) qsort(h,y);\\n}\\n\\t\\nint getfather(int x)//找根结点，并压缩路径，此处用递归实现的。\\n{\\n\\tif(x==father[x]) return x;\\n\\telse \\n\\t{\\n\\t\\tint f=getfather(father[x]);\\n\\t\\tfather[x]=f;\\n\\t\\treturn f;\\n\\t}\\n}\\n\\t\\nvoid merge(int x,int y)//合并x,y结点，在此题中的x,y为两个根结点。\\n{\\n\\tfather[x]=y;\\n}\\n\\t\\nvoid kruscal(void)\\n{\\n\\tint sum=0,ans=0;\\n\\tqsort(1,t);//对t条边按权值大小按从小到大的次序进行快速排序\\n\\tfor(int i=1;i<=t;i++)\\n\\t{\\n\\t\\tint x1=getfather(elist[i].from);//取第i条边的起点所在的树的根\\n\\t\\tint x2=getfather(elist[i].to);// 取第i条边的终点所在的树的根\\n\\t\\tif(x1!=x2)\\n\\t\\t{\\n\\t\\t\\tsum++;\\n\\t\\t\\tmerge(x1,x2);\\n\\t\\t\\tans+=elist[i].w;\\n\\t\\t}//不在同一个集合，合并，即第i条边可以选取。\\n\\tif(sum>n-1)\\n\\t\\tbreak;//已经确定了n-1条边了，最小生成树已经生成了，可以提前退出循环了\\n\\t}\\n\\tif(sum<n-1)\\n\\t\\tcout<<\"Impossible\"<<endl; //从t条边中无法确定n-1条边，说明无法生成最小生成树\\n\\telse \\t\\n\\t\\tcout<<ans<<endl;\\n}\\n"}
{"index":{}}
{"id": "12", "language": "C&C++", "method_body": "void maketable int x X prim prim i i n n tmemset prim sizeof prim n tprim prim prim X n tfor int i i x i n t t tif prim i n t t t t int j i n t t t t twhile j x n t t t t t t prim j j j i n n n", "content": "void maketable(int x)//建立X以内的素数表prim，prim[i]为0，表示i为素数，为1表示不是质数\\n{\\n\\tmemset(prim,0,sizeof(prim));//初始化质数表\\n\\tprim[0]=1;prim[1]=1;prim[2]=0;//用筛选法求X以内的质数表\\n\\tfor(int i=2;i<=x;i++)\\n\\t\\t\\tif (prim[i]==0)\\n\\t\\t\\t\\t{int j=2*i;\\n\\t\\t\\t\\t\\twhile(j<=x)\\n\\t\\t\\t\\t\\t\\t{prim[j]=1;j=j+i;}\\n}\\n}\\n"}
{"index":{}}
{"id": "13", "language": "C&C++", "method_body": "void merge int l int m int r l m m r n int b B b n tint h t k n tk B n th l t m h t n twhile h m t r h t n t t n t t tk t t t t n t t tif a h a t b k a h h t t t t n t t telse b k a t t t t n t t n twhile h m n t n t tk n t tb k a h n t th n t t n twhile t r n t n t tk n t tb k a t n t tt n t t t n tfor int o o k o n t ta l o b o n nvoid mergesort int x int y x y n n tint mid n tif x y return n tmid x y x y mid mid x y n tmergesort x mid n tmergesort mid y n tmerge x mid y n n", "content": "void merge(int l,int m,int r)//合并[l,m]和[m+1,r]两个已经有序的区间\\n{ int b[101];//借助一个新的数组B，使两个有序的子区间合并成一个有序的区间，b数组的大小要注意\\n\\tint h,t,k;\\n\\tk=0;//用于新数组B的指针\\n\\th=l;t=m+1;//让h指向第一个区间的第一个元素，t指向第二个区间的第一个元素。\\n\\twhile((h<=m)&&(t<=r))//在指针h和t没有到区间尾时，把两个区间的元素抄在新数组中\\n\\t\\t{\\n\\t\\t\\tk++;\\t\\t\\t\\t//新数组指针加1\\n\\t\\t\\tif (a[h]<a[t]){b[k]=a[h];h++;}\\t\\t\\t\\t//抄第一个区间元素到新数组\\n\\t\\t\\telse{b[k]=a[t];t++;}\\t\\t//抄第二个区间元素到新数组\\n\\t\\t}\\n\\twhile(h<=m)\\n\\t{\\n\\t\\tk++;\\n\\t\\tb[k]=a[h];\\n\\t\\th++;\\n\\t}\\t//如果第一个区间没有抄结束，把剩下的抄在新数组中\\n\\twhile(t<=r)\\n\\t{\\n\\t\\tk++;\\n\\t\\tb[k]=a[t];\\n\\t\\tt++;\\n\\t}\\t\\t//如果第二个区间没有抄结束，把剩下的抄在新数组中\\n\\tfor(int o=1;o<=k;o++)//把新数组中的元素，再抄回原来的区间，这两个连续的区间变为有序的区间。\\n\\t\\ta[l+o-1]=b[o];\\n}\\nvoid mergesort(int x,int y)//对区间[x,y]进行二路归并排序\\n{\\n\\tint mid;\\n\\tif(x>=y) return;\\n\\tmid=(x+y)/2;//求[x,y]区间，中间的那个点mid,mid把x,y区间一分为二\\n\\tmergesort(x,mid);//对前一段进行二路归并\\n\\tmergesort(mid+1,y);//对后一段进行二路归并\\n\\tmerge(x,mid,y);//把已经有序的前后两段进行合并\\n}\\n"}
{"index":{}}
{"id": "14", "language": "C&C++", "method_body": " include iostream n include cstring nusing namespace std nint main n n tstring str str n tint a b c len t t t n tint i j n tmemset a sizeof a n tmemset b sizeof b n tcin str str n ta str length n tfor i i a i n t t ta i str a i n tb str length n tfor i i b i n t t tb i str b i n tmemset c sizeof c n tfor i i a i t t n t t tfor j j b j n t t t n t t tc i j a i b j n t t tc i j c i j n t t tc i j t t t n t t t n tlen a b t n twhile c len len len t t len t t n tfor i len i i n t t tcout c i n treturn t n n", "content": "#include<iostream>\\n#include<cstring>\\nusing namespace std;\\nint main()\\n{\\n\\tstring str1,str2;\\n\\tint a[250],b[250],c[500],len; \\t\\t\\t//250位以内的两个数相乘\\n\\tint i,j;\\n\\tmemset(a,0,sizeof(a));\\n\\tmemset(b,0,sizeof(b));\\n\\tcin>>str1>>str2;\\n\\ta[0]=str1.length();\\n\\tfor(i=1;i<=a[0];i++)\\n\\t\\t\\ta[i]=str1[a[0]-i]-'0';\\n\\tb[0]=str2.length();\\n\\tfor(i=1;i<=b[0];i++)\\n\\t\\t\\tb[i]=str2[b[0]-i]-'0';\\n\\tmemset(c,0,sizeof(c));\\n\\tfor(i=1;i<=a[0];i++)\\t\\t//做按位乘法同时处理进位，注意循环内语句的写法。\\n\\t\\t\\tfor(j=1;j<=b[0];j++)\\n\\t\\t\\t{\\n\\t\\t\\tc[i+j-1]+=a[i]*b[j];\\n\\t\\t\\tc[i+j]+=c[i+j-1]/10;\\n\\t\\t\\tc[i+j-1]%=10;\\t\\t\\t\\n\\t\\t\\t}\\n\\tlen=a[0]+b[0]+1;\\t//去掉最高位的0，然后输出\\n\\twhile((c[len]==0)&&(len>1)) len--;\\t\\t//为什么此处要len>1\\t\\t\\n\\tfor(i=len;i>=1;i--)\\n\\t\\t\\tcout<<c[i];\\n\\treturn 0;\\t\\n}\\n"}
{"index":{}}
{"id": "15", "language": "C&C++", "method_body": "void prime void prim elist i a i j I j edge n n tfor int i i n i n n t t n t telist i from n t telist i to i n t telist i w a i n t n tfor int i i n i n n t t n t tint m i n t tfor int j i j n j i i n n t t tif elist j w elist m w m j n t tif m i i n t t n t t tedge tmp elist i elist i elist m elist m tmp n t t tfor int j i j n j i n n t t t n t t t tif elist j w a elist i to elist j to n t t t t telist j w a elist i to elist j to n t t t n t t t t t t t t t t t t t t t t t t t t t t t t t t t t t n tfor int i i n i n t tans ans elist i w n n", "content": "void prime(void) //prim算法求最小生成树，elist[i]是边集数组，a[i][j]为<I,j>的权值。edge为结构体类型。\\n{\\n\\tfor (int i=1;i<=n-1;i++)//初始化结点1到其它n-1个结点形成的边集\\n\\t{\\t\\n\\t\\telist[i].from=1;\\n\\t\\telist[i].to=i+1;\\n\\t\\telist[i].w=a[1][i+1];\\n\\t}\\n\\tfor (int i=1;i<=n-1;i++)//依次确定n-1条边\\n\\t{\\t\\n\\t\\tint m=i;\\n\\t\\tfor(int j=i+1;j<=n-1;j++)//确定第i条边时，依次在i+1至n-1条边中找最小的那条边\\n\\t\\t\\tif(elist[j].w<elist[m].w) m=j;\\n\\t\\tif(m!=i) //如果最小的边不是第i条边就交换\\n\\t\\t{\\n\\t\\t\\tedge tmp=elist[i];elist[i]=elist[m];elist[m]=tmp;}\\n\\t\\t\\tfor(int j=i+1;j<=n-1;j++)//更新第i+1至n-1条边的最小距离。\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(elist[j].w>a[elist[i].to][elist[j].to]) \\n\\t\\t\\t\\t\\telist[j].w=a[elist[i].to][elist[j].to];\\n\\t\\t\\t}\\n\\t}\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\tfor(int i=1;i<=n-1;i++)//求最小生成树的值\\n\\t\\tans=ans+elist[i].w;\\n}\\n"}
{"index":{}}
{"id": "16", "language": "C&C++", "method_body": "void qsort int x int y a a n n n tint h x r y n tint m a x y n twhile h r n t n t twhile a h m h n t t twhile a r m n t t t tr n t tif h r n t t t n t t tint temp a h h r a h a r n t t ta h a r n t t ta r temp n t t th r n t t n t n tif r x qsort x r n tif h y qsort h y n n", "content": "void qsort(int x,int y) //待排序的数据存放在a[1]..a[n]数组中\\n{\\n\\tint h=x,r=y;\\n\\tint m=a[(x+y)>>1]; //取中间的那个位置的值\\n\\twhile(h<r)\\n\\t{\\n\\t\\twhile (a[h]<m) h++; //比中间那个位置的值小，循环直到找一个比中间那个值大的\\n\\t\\t\\twhile (a[r]>m) \\n\\t\\t\\t\\tr--; //比中间那个位置的值大，循环直到找一个比中间那个值小的\\n\\t\\tif(h<=r)\\n\\t\\t{\\t\\n\\t\\t\\tint temp=a[h];//如果此时h<=r，交换a[h]和a[r]\\n\\t\\t\\ta[h]=a[r];\\n\\t\\t\\ta[r]=temp;\\n\\t\\t\\th++;r--; //这两句必不可少哦\\n\\t\\t}\\n\\t}\\n\\tif(r>x) qsort(x,r);//注意此处，尾指针跑到前半部分了\\n\\tif(h<y) qsort(h,y); //注意此处，头指针跑到后半部分了\\n}\\n"}
{"index":{}}
{"id": "17", "language": "C&C++", "method_body": " include iostream nusing namespace std nint compare string s string s nint main n n tstring str str n tint a b len n tint i n tmemset a sizeof a n tmemset b sizeof b n tcin str str n ta str length n tfor i i a i n t ta i str a i n tb str length n tfor i i b i n t tb i str b i n tif compare str str t n t n t tfor i i a i n t t t a i b i n t t t if a i a i a i n t t t n t ta n t twhile a a a a n t tfor i a i i n t t tcout a i n t tcout endl t n t t t t t t t t t t t t t t n telse n t n t tcout t n t tfor i i b i t n t t t b i a i n t t t if b i b i b i n t t t n t tb n t twhile b b b b n t tfor i b i i n t t tcout b i n t tcout endl t t t t n t n treturn n nint compare string s string s t n n tif s length s length return t n tif s length s length return n tfor int i i s length i t n t n t tif s i s i return n t tif s i s i return t t t t t t t t t t t t t n t n treturn t n n", "content": "#include<iostream>\\nusing namespace std;\\nint compare(string s1,string s2);\\nint main()\\n{\\n\\tstring str1,str2;\\n\\tint a[250],b[250],len;\\n\\tint i;\\n\\tmemset(a,0,sizeof(a));\\n\\tmemset(b,0,sizeof(b));\\n\\tcin>>str1>>str2;\\n\\ta[0]=str1.length();\\n\\tfor(i=1;i<=a[0];i++)\\n\\t\\ta[i]=str1[a[0]-i]-'0';\\n\\tb[0]=str2.length();\\n\\tfor(i=1;i<=b[0];i++)\\n\\t\\tb[i]=str2[b[0]-i]-'0';\\n\\tif((compare(str1,str2))==0)\\t//大于等于，做按位减，并处理借位。\\n\\t{\\n\\t\\tfor(i=1;i<=a[0];i++)\\n\\t\\t\\t{a[i]-=b[i];\\n\\t\\t\\t if (a[i]<0) {a[i+1]--;a[i]+=10;}\\n\\t\\t\\t}\\n\\t\\ta[0]++;\\n\\t\\twhile((a[a[0]]==0)&&(a[0]>1)) a[0]--;\\n\\t\\tfor(i=a[0];i>=1;i--)\\n\\t\\t\\tcout<<a[i];\\n\\t\\tcout<<endl;\\t\\n\\t}\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\t\\t\\n\\telse\\n\\t{\\n\\t\\tcout<<'-';\\t//小于就输出负号\\n\\t\\tfor(i=1;i<=b[0];i++)\\t//做按位减，大的减小的\\n\\t\\t\\t{b[i]-=a[i];\\n\\t\\t\\t if (b[i]<0) {b[i+1]--;b[i]+=10;}\\n\\t\\t\\t}\\n\\t\\tb[0]++;\\n\\t\\twhile((b[b[0]]==0)&&(b[0]>1)) b[0]--;\\n\\t\\tfor(i=b[0];i>=1;i--)\\n\\t\\t\\tcout<<b[i];\\n\\t\\tcout<<endl;\\t\\t\\t\\t\\n\\t}\\n\\treturn 0;\\n}\\nint compare(string s1,string s2)\\t//比较字符串（两个数）数字的大小，大于等于返回0，小于返回1。\\n{\\n\\tif(s1.length()>s2.length()) return 0;\\t//先比较长度，哪个字符串长，对应的那个数就大\\n\\tif(s1.length()<s2.length()) return 1;\\n\\tfor(int i=0;i<=s1.length();i++)\\t//长度相同时，就一位一位比较。\\n\\t{\\n\\t\\tif(s1[i]>s2[i]) return 0;\\n\\t\\tif(s1[i]<s2[i]) return 1;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t}\\n\\treturn 0;\\t //如果长度相同，每一位也一样，就返回0，说明相等\\n}\\n"}
{"index":{}}
{"id": "18", "language": "C&C++", "method_body": "void preorder int x n t n t tif x return n t tcout x n t tpreorder a x ld n t tpreorder a x rd n n t nvoid inorder int x n t n t tif x return n t tpreorder a x ld n t tcout x n t tpreorder a x rd n n t nvoid reorder int x n t n t tif x return n t tpreorder a x ld n t tpreorder a x rd n t tcout x n n", "content": "void preorder(int x)//二叉树的先序遍历\\n\\t{\\n\\t\\tif(x==0) return;\\n\\t\\tcout<<x;//先访问根\\n\\t\\tpreorder(a[x].ld);//再先序遍历根的左子树\\n\\t\\tpreorder(a[x].rd);//最后先序遍历根的右子树\\n}\\n\\t\\nvoid inorder(int x)//二叉树的中序遍历\\n\\t{\\n\\t\\tif(x==0) return;\\n\\t\\tpreorder(a[x].ld);//先中序遍历根的左子树\\n\\t\\tcout<<x;//再访问根\\n\\t\\tpreorder(a[x].rd);//最后中序遍历根的右子树\\n}\\n\\t\\nvoid reorder(int x)//二叉树的后序遍历\\n\\t{\\n\\t\\tif(x==0) return;\\n\\t\\tpreorder(a[x].ld);//先后序遍历根的左子树\\n\\t\\tpreorder(a[x].rd);//再后序遍历根的右子树\\n\\t\\tcout<<x;//最后访问根\\n}\\n"}
