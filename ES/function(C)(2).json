{"index":{}}
{"id": "40", "language": "C&C++", "method_body": "int getfather int x X n n twhile x father x n t tx father x n treturn x n n t nint getfather int x X n n tif x father x return x n telse return getfather father x t n n t nint getfather int x X n n tint p x n twhile p father p P n t tp father p n twhile x father x X X n t t n t t tint temp father x X n t t tfather x p X P n t t tx temp n t t n treturn p n n t nint getfather int x X n n tif x father x return x n telse n t n t tint temp getfather father x n t tfather x temp n t treturn temp n t n n t nvoid merge int x int y x y n n t tint x x n t tx getfather x X n t tx getfather y Y n t tif x x father x x X Y n n", "content": "int getfather(int x)/*非递归求X结点的根结点的编号*/\\n{\\n\\twhile(x!=father[x])\\n\\t\\tx=father[x];\\n\\treturn x;\\n}\\n\\t\\nint getfather(int x)/*递归求X结点的根结点的编号*/\\n{\\n\\tif(x==father[x]) return x;\\n\\telse return getfather(father[x]);\\t\\n}\\n\\t\\nint getfather(int x)/*非递归求X结点的根结点编号同时进行路径压缩*/\\n{\\n\\tint p=x;\\n\\twhile(p!=father[p])/*循环结束后，P即为根结点*/\\n\\t\\tp=father[p];\\n\\twhile(x!=father[x])/*从X结点沿X的父结点进行路径压缩*/\\n\\t\\t{\\n\\t\\t\\tint temp=father[x];/*暂存X没有修改前的父结点*/\\n\\t\\t\\tfather[x]=p;/*把X的父结点指向P*/\\n\\t\\t\\tx=temp;\\n\\t\\t}\\n\\treturn p;\\n}\\n\\t\\nint getfather(int x)/*递归求X结点的根结点编号同时进行路径压缩*/\\n{\\n\\tif(x==father[x]) return x;\\n\\telse\\n\\t{\\n\\t\\tint temp=getfather(father[x]);\\n\\t\\tfather[x]=temp;\\n\\t\\treturn temp;\\n\\t}\\n}\\n\\t\\nvoid merge(int x,int y)/*合并x,y两个结点*/\\n{\\n\\t\\tint x1,x2;\\n\\t\\tx1=getfather(x);/*取得X的父结点*/\\n\\t\\tx2=getfather(y);/*取得Y的父结点*/\\n\\t\\tif(x1!=x2) father[x1]=x2; /*两个父结点不同的话就合并，注意：合并的是X，Y两个结点的根。*/\\n}\\n"}
{"index":{}}
{"id": "41", "language": "C&C++", "method_body": "void huffman void n n t preoder SPFA inoder postorder getfather huffman inorder preorder n tfor int i n i n i n n t n t tint l fmin i l n t ta i lchild l l i n t ta l father i l i n t tint r fmin i r n t ta i rchild r l i n t ta r father i r i n t ta i da a l da a r da l j i n t n nint fmin int k K n n tint mins n tfor int s s k s n t tif a mins da a s da a s father a s father n tmins s n treturn mins n nvoid inorder int x n n tif a x father a x code n tif a a x father lchild x ta x code a a x father code n tif a a x father rchild x ta x code a a x father code n tif a x lchild inorder a x lchild n tif a x lchild a x rchild n t tcout a x da a x code endl n tif a x rchild inorder a x rchild n n", "content": "void huffman(void) /*构建哈夫曼树*/\\n{\\n\\t/* preoder  SPFA inoder postorder getfather huffman inorder preorder*/\\n\\tfor(int i=n+1;i<=2*n-1;i++) /*依次生成n-1个结点*/\\n\\t{\\n\\t\\tint l=fmin(i-1); /*查找权值最小的结点的编号l*/\\n\\t\\ta[i].lchild=l; /*把l作为结点i的左孩子*/\\n\\t\\ta[l].father=i; /*把l的父结点修改为i*/\\n\\t\\tint r=fmin(i-1); /*查找次小权值的编号r*/\\n\\t\\ta[i].rchild=r; /*把l作为结点i的右孩子*/\\n\\t\\ta[r].father=i; /*把r的父结点修改为i*/\\n\\t\\ta[i].da=a[l].da+a[r].da; /*合并l,j结点，生成新结点i*/\\n\\t}\\n}\\nint fmin(int k)/*在1到K中寻找最小的权值的编号*/\\n{\\n\\tint mins=0;\\n\\tfor(int s=1;s<=k;s++)\\n\\t\\tif((a[mins].da>a[s].da)&&(a[s].father==0)) /*a[s].father=0,说明这个结点还不是别个结点*/\\n\\tmins=s;/*的孩子，不等于0说明这个结点已经用过。*/\\n\\treturn mins;\\n}\\nvoid inorder(int x)/*递归生成哈夫曼编码*/\\n{\\n\\tif(a[x].father==0) {a[x].code=\"\";}/*根结点*/\\n\\tif(a[a[x].father].lchild==x)\\ta[x].code=a[a[x].father].code+'0';\\n\\tif(a[a[x].father].rchild==x)\\ta[x].code=a[a[x].father].code+'1';\\n\\tif(a[x].lchild!=0) inorder(a[x].lchild);/*递归生成左子树*/\\n\\tif((a[x].lchild==0)&&(a[x].rchild==0))/*输出叶子结点*/\\n\\t\\tcout<<a[x].da<<':'<<a[x].code<<endl;\\n\\tif(a[x].rchild!=0) inorder(a[x].rchild);/*递归生成右子树*/\\n}\\n"}
{"index":{}}
{"id": "42", "language": "C&C++", "method_body": "void postorder int x n n t preoder SPFA inoder postorder getfather huffman inorder preorder n t tif x return n t tpreorder a x ld n t tpreorder a x rd n t tcout x n n", "content": "void postorder(int x)/*二叉树的后序遍历*/\\n{\\n\\t/* preoder  SPFA inoder postorder getfather huffman inorder preorder*/\\n\\t\\tif(x==0) return;\\n\\t\\tpreorder(a[x].ld);/*先后序遍历根的左子树*/\\n\\t\\tpreorder(a[x].rd);/*再后序遍历根的右子树*/\\n\\t\\tcout<<x;/*最后访问根*/\\n}\\n"}
{"index":{}}
{"id": "43", "language": "C&C++", "method_body": "void preoder BT T n n t preoder SPFA inoder postorder getfather huffman inorder preorder n if T return n ST stack n stack top n BT p T n while stack top p n n while p n n printf c p data n stack t stack top p n p p left n n if stack top n n p stack t stack top n p p right n n n printf n n n n", "content": "void preoder(BT* T)\\n{\\n\\t/* preoder  SPFA inoder postorder getfather huffman inorder preorder*/\\n    if (!T) return;\\n    ST stack1;\\n    stack1.top = 0;\\n    BT* p = T;\\n    while (stack1.top || p)\\n    {\\n        while (p)\\n        {\\n            printf(\"%c \",p->data);\\n            stack1.t[stack1.top++] = p;\\n            p = p->left;\\n        }\\n        if (stack1.top)\\n        {\\n            p = stack1.t[--stack1.top];\\n            p = p->right;\\n        }\\n    }\\n    printf(\"\\n\");\\n}\\n\\n"}
{"index":{}}
{"id": "44", "language": "C&C++", "method_body": "void inoder BT T n n t preoder SPFA inoder postorder getfather huffman inorder preorder n if T return n ST stack n stack top n BT p T n while p stack top n n while p n n stack t stack top p n p p left n n if stack top n n p stack t stack top n printf c p data n p p right n n n printf n n n n", "content": "void inoder(BT* T)\\n{\\n\\t/* preoder  SPFA inoder postorder getfather huffman inorder preorder*/\\n    if (!T) return;\\n    ST stack1;\\n    stack1.top = 0;\\n    BT* p = T;\\n    while (p || stack1.top)\\n    {\\n        while (p)\\n        {\\n            stack1.t[stack1.top++] = p;\\n            p = p->left;\\n        }\\n        if (stack1.top)\\n        {\\n            p = stack1.t[--stack1.top];\\n            printf(\"%c \", p->data);\\n            p = p->right;\\n        }\\n    }\\n    printf(\"\\n\");\\n}\\n\\n"}
{"index":{}}
{"id": "45", "language": "C&C++", "method_body": "void postorder BT T n n t preoder SPFA inoder postorder getfather huffman inorder preorder n ST stack n stack top n BT p p n p T n do n n while p n n stack t stack top p n p p left n n p NULL n while stack top n n p stack t stack top n if p right p n n printf c p data n stack top n p p n n else n n p p right n n n n while stack top n n n", "content": "void postorder(BT* T)\\n{\\n\\t/* preoder  SPFA inoder postorder getfather huffman inorder preorder*/\\n    ST stack1;\\n    stack1.top = 0;\\n    BT* p, * p1;\\n    p = T;\\n    do\\n    {\\n        while (p)\\n        {\\n            stack1.t[stack1.top++] = p;\\n            p = p->left;\\n        }\\n        p1 = NULL;\\n        while (stack1.top)\\n        {\\n            p = stack1.t[stack1.top - 1];\\n            if (p->right == p1) /*无右节点或者已经被访问出栈*/\\n            {\\n                printf(\"%c \", p->data);\\n                stack1.top--;\\n                p1 = p;\\n            }\\n            else\\n            {\\n                p = p->right;\\n            }\\n\\n        }\\n    } while (stack1.top);\\n}\\n\\n"}
{"index":{}}
{"id": "46", "language": "C&C++", "method_body": "bool SPFA int s int n n t preoder SPFA inoder postorder getfather huffman inorder preorder n tqueue int q n tmemset vis inf sizeof vis n tmemset ven sizeof ven n tmemset nums sizeof nums n tvis s n tven s nums s s n tq push s n twhile q empty n t n t tint x q front n t tq pop n t tven x n t tfor int i pre x i i a i next x n t t n t t tint y a i y n t t tif vis y vis x a i time n t t t n t t t tvis y vis x a i time n t t t tif ven y n t t t t n t t t t n t t t t n t t t t tq push y n t t t t tven y n t t t t tnums y n t t t t tif nums y n n n t t t t t treturn false n t t t t n t t t n t t n t n treturn true n n", "content": "bool SPFA(int s,int n){\\n\\t/* preoder  SPFA inoder postorder getfather huffman inorder preorder*/\\n\\tqueue <int> q;\\n\\tmemset(vis,inf,sizeof(vis));\\n\\tmemset(ven,0,sizeof(ven));\\n\\tmemset(nums,0,sizeof(nums));\\n\\tvis[s]=0;/*初始化距离 */\\n\\tven[s]=1,nums[s]++;/*标记s节点在队列，队列次数+1*/ \\n\\tq.push(s);\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tint x=q.front();\\n\\t\\tq.pop();/*出队 */\\n\\t\\tven[x]=0;/*标记不在队列 */\\n\\t\\tfor(int i=pre[x]; ~i; i=a[i].next)/*遍历与x节点连通的点 */\\n\\t\\t{\\n\\t\\t\\tint y=a[i].y;\\n\\t\\t\\tif(vis[y]>vis[x]+a[i].time)/*更新*/ \\n\\t\\t\\t{\\n\\t\\t\\t\\tvis[y]=vis[x]+a[i].time;\\n\\t\\t\\t\\tif(!ven[y])\\n\\t\\t\\t\\t/*由于更新了节点，所以后续以这个为基础的最短路，也要更新下*/\\n\\t\\t\\t\\t/*所以如果在队列就不用加入，不在的话加入更新后续节点 */\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tq.push(y);\\n\\t\\t\\t\\t\\tven[y]=1;/*标记这个节点在队列中 */\\n\\t\\t\\t\\t\\tnums[y]++;/*记录加入次数 */\\n\\t\\t\\t\\t\\tif(nums[y]>n)/*如果这个点加入超过n次，说明存在负圈，直接返回 */\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n\\n"}
{"index":{}}
{"id": "47", "language": "C&C++", "method_body": "void preorder int x n n t preoder SPFA inoder postorder getfather huffman inorder preorder n t tif x return n t tcout x n t tpreorder a x ld n t tpreorder a x rd n n", "content": "void preorder(int x)/*二叉树的先序遍历*/\\n{\\n\\t/* preoder  SPFA inoder postorder getfather huffman inorder preorder*/\\n\\t\\tif(x==0) return;\\n\\t\\tcout<<x;/*先访问根\\n\\t\\tpreorder(a[x].ld);/*再先序遍历根的左子树*/\\n\\t\\tpreorder(a[x].rd);/*最后先序遍历根的右子树*/\\n}\\n"}
{"index":{}}
{"id": "48", "language": "C&C++", "method_body": "void inorder int x n n t preoder SPFA inoder postorder getfather huffman inorder preorder n t tif x return n t tpreorder a x ld n t tcout x n t tpreorder a x rd n n n", "content": "void inorder(int x)/*二叉树的中序遍历*/\\n{\\n\\t/* preoder  SPFA inoder postorder getfather huffman inorder preorder*/\\n\\t\\tif(x==0) return;\\n\\t\\tpreorder(a[x].ld);/*先中序遍历根的左子树*/\\n\\t\\tcout<<x;/*再访问根*/\\n\\t\\tpreorder(a[x].rd);/*最后中序遍历根的右子树*/\\n}\\n\\n"}
